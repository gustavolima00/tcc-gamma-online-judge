\chapter[Fundamentação Teórica]{Fundamentação Teórica}
\label{chap:ft}

Neste capítulo são apresentados os conceitos fundamentais para o embasamento da reflexão proposta, serão abordados os conceitos a respeito de juízes eletrônicos e juízes online, maratonas de programação e tecnologias utilizadas na arquitetura do GOJ. O capítulo está dividido nas seguintes seções: \nameref{sec:maratonasDeProgramação}, onde são abordados os conceitos de maratonas de programação e programação competitiva; \nameref{sec:maratonasUnB}, que contextualiza os eventos das Maratonas UnB de programação; \nameref{sec:juizesOnline}, que trata da definição de um juiz online e o impacto do contato de alunos com essa tecnologia; \nameref{sec:microServicos}, que aborda a definição da arquitetura de micro-serviços. \nameref{sec:apis}, que discorre sobre a definição de Web APIs; \nameref{sec:desenvolvimentoWEB}, que aborda sobre desenvolvimento web. 


\section{Maratonas de programação}
\label{sec:maratonasDeProgramação}

Programação competitiva é um termo usado para competições, onde os participantes resolvem problemas conhecidos de Ciência da Computação o mais rápido possível. Os problemas resolvidos não são inéditos, baseados em conhecimentos de Ciência da Computação, eles são conhecidos pelo menos pelo autor ou autores do problema, que o elaborou e possui sua solução. Para los resolver, os participantes devem colocar em prática os conhecimentos de ciência da computação, elaborando uma solução que passará por testes ocultos; os testes realizados na solução do participante devem ter resultados iguais aos resultados da solução do problema. A competitividade se encontra com a resolução dos problemas o mais rápido possível.

\begin{quote}

The core directive in ‘Competitive Programming’ is this: “Given well-known Computer Science (CS) problems, solve them as quickly as possible!”.

Let’s digest the terms one by one. The term ‘well-known CS problems’ implies that in competitive programming, we are dealing with solved CS problems and not research problems (where the solutions are still unknown). Some people (at least the problem author) have definitely solved these problems before. To ‘solve them’ implies that we must push our CS knowledge to a certain required level so that we can produce working code that can solve these problems too—at least in terms of getting the same output as the problem author using the problem author’s secret test data within the stipulated time limit. The need to solve the problem ‘as quickly as possible’ is where the competitive element lies—speed is a very natural goal in human behavior.
\cite[p.1]{halim2013competitive}
\end{quote}

Maratona de programação é um termo adaptado do inglês \textit{Programing Contest}; são competições, utilizando programação competitiva. As competições possuem uma lista de problemas de programação competitiva, onde os competidores devem tentar resolvê-los no menor tempo possível. Para cada tentativa de resolução do problema, o competidor consegue acompanhar se sua solução apresentou o comportamento esperado ou não\footnote{Além de ter as respostas esperadas em cada um dos casos de testes ocultos, é importante que a solução utilize os recursos de tempo e memória estabelecidos no problema. Logo, uma solução que apresentou o comportamento esperado não se limita apenas as soluções com as saídas corretas para os casos de teste}; soluções incorretas ou que não apresentaram o comportamento esperado podem penalizar o competidor, encorajando que os competidores sejam não somente rápidos, como também precisos. Muitas maratonas de programação são em equipe, o que faz com que os competidores coloquem em prática não só os conhecimentos de ciência da computação, como também o trabalho em equipe.

\begin{quote}
It’s clear that a programming contest is, by its own definition, a competitive activity,
where there are winners and others (not really losers, in general).[\dots]. Moreover, many of the programming contests are team competitions and they involve a lot of collaborative work to prepare them.
\cite[p.132]{revilla2008competitive}
\end{quote}

O formato mais comum das maratonas é o utilizado no ICPC (\textit{International Collegiate Programming Contest}). O ICPC teve início no ano de 1977 em Atlanta, e conta com o total de 44 edições até a edição de 2020. A competição é feita entre equipes, que recebem uma lista de problemas para resolver em um tempo pré estabelecido de prova. Cada equipe é composta por três participantes\footnote{Em alguns caso o equipe pode conter um participante reserva, formando uma equipe com 4 participantes, porém apenas 3 participantes podem participar da competição}, que trabalham em equipe para resolver os problemas. Os times são classificados pelo maior número de problemas resolvidos, caso mais de uma equipe tenha o mesmo número de problemas resolvidos a classificação desses times é feita pelo menor tempo total gasto para resolver os problemas. O tempo gasto para resolver um problema se dá pelo intervalo de tempo do início da competição até a primeira submissão aceita pelo juiz mais 20 minutos de penalidade por cadas submissão anterior errada \cite{aboutICPC}. 

\section{Maratonas UnB de Programação}
\label{sec:maratonasUnB}

As Maratonas UnB de Programação são eventos baseados no ICPC e realizados pela UnB (Universidade de Brasília). A primeira edição do evento foi realizada em 2013 no LINF (Laboratório de Informática) da UnB — campus Darcy Ribeiro. O evento teve, até o momento, 9 edições no total, com suas 2 últimas edições realizadas 100\% online devido à pandemia de COVID-19.

A participação das equipes nas maratonas UnB de programação é variada. Não limitada apenas à UnB, também houve a participação de universidades de outros estados no evento. Em 2017, em sua quinta edição, a Maratona UnB de programação teve participação da Universidade Federal de Uberlândia (UFU), Universidade de São Paulo (USP) e Pontifícia Universidade Católica de Goiás (PUC-GO), além disso, o evento também não se limita a universidades públicas, o Instituto Federal de Brasília (IFB) e a faculdade IESB também já estiveram presentes em edições do evento.

As Maratonas UnB de Programação tem motivado alunos iniciantes com um bom desempenho em programação a se desafiarem, competindo contra programadores mais experientes. Além disso, muitas equipes que competiram nessa maratona alcançaram bons resultados em edições do ICPC.

O sistema utilizado nos eventos variaram segundo as edições. O mais utilizado foi o BOCA \cite{de2004boca}, mesmo sistema utilizado em competições ICPC regionais e nacionais. Além do BOCA, para as edições VI, VIII e IX foi utilizada a plataforma \textit{Codeforces}.

\section{Juízes Onlines}
\label{sec:juizesOnline}

Em maratonas de programação são utilizados juízes eletrônicos, corretores automáticos de problemas. No momento em que um competidor submete o código de um problema, o juiz eletrônico é responsável por compilar o código recebido, gerando um programa, executar o programa em uma lista de testes e determinar o veredito da solução. O veredito da solução se dá pelas saídas do problema nos testes e pelo comportamento do programa durante a execução, além de possuir as saídas esperadas para cada um dos testes executados, o programa deve utilizar os recursos de tempo e memória determinados no problema; além disso, o programa executado não pode apresentar um comportamento inesperado, como parar a execução no meio dos testes, ou utilizar recursos não permitidos pelo problema, como, por exemplo, paralelismo\footnote{Os juízes podem ser configurados para não permitir que o programa execute tarefas em paralelo, porém essa não é uma regra, existem casos onde esse recurso pode ser permitido}. 

Ao enviar um problema para um juiz eletrônico, sua correção pode variar, dependendo das saídas esperadas do programa e os recursos gastos para execução. Quando o programa tem saídas diferentes das esperadas, o veredito retornado é \textit{Wrong Answer} (WA); caso o tempo de execução do programa seja maior que o esperado, o veredito é \textit{Time Limit Exceeded} (TLE); se o software utilizar mais memória do que permitido o juiz retorna \textit{Memory Limit Exceeded} (MLE); e por fim se as saídas do software forem iguais aos resultados esperadas e o software utilizar os recursos permitidos o veredito é \textit{Accepted} (AC). Existem outros vereditos como: \textit{Compilation Error} (CE), retornado quando existe algum erro com a compilação do código; \textit{Runtime Error} (RTE) retornado quando o programa executado apresenta um erro durante a execução; e outros vereditos que podem ser retornados dependendo do juiz eletrônico e o problema para o qual o código foi enviado.  

% A correção de problemas pode ser realizada tanto online quanto \textit{offline}, isso depende da maneira como o juiz foi desenvolvido e utilizado \cite{KURNIA2001299}. Define-se um juiz online sendo um juiz eletrônico disposto em um site ou conjunto de páginas.

Um juiz online é em uma plataforma online com problemas de programação competitiva, que permite que soluções sejam enviadas para seus problemas e que essas soluções sejam julgadas. São exemplos de juízes onlines plataformas como: Codeforces\footnote{\url{https://codeforces.com/}}, Becrowd\footnote{\url{https://www.beecrowd.com.br/}} e LeetCode\footnote{\url{https://leetcode.com/}}; cada uma dessas plataformas possui um juiz eletrônico próprio para julgar os problemas enviados. Além dos juízes eletrônicos próprios das plataformas, existem juízes eletrônicos de código aberto como: BOCA\footnote{\url{https://www.ime.usp.br/~cassio/boca/}}, MOJ TOOLS\footnote{\url{https://github.com/cd-moj/mojtools}} e Ejudge\footnote{\url{https://ejudge.ru/}}.

Atualmente, além de maratonas de programação, juízes online são bastante utilizados para o ensino de programação básica. \citeonline{francisco2016juiz} ressaltam os benefícios da utilização de um juiz online no ensino de matérias inicias de programação:

\begin{quote}
    ``[\dots] Aprendizagem no ritmo do aluno, auto-aprendizagem e redução da carga de trabalho do professor, são alguns dos benefícios apontados que contribuem não só em ambientes tradicionais de ensino, mas em ambientes de Educação a Distancia (EAD) e em MOOC’s. A liberdade de definir listas de exercício e a disponibilidade de instrumentos para acompanhar os alunos são questões importantes para o professor.'' \cite[p.18-19]{francisco2016juiz}
\end{quote}

Com a introdução de alunos aos juízes online, o ambiente de maratonas de programação se torna mais familiar. Isso se dá ao fato das maratonas utilizarem um formato de questões parecido ou até mesmo igual ao formato de juízes online. O envolvimento de alunos com maratonas se mostra positivo em relação aos seus resultados com disciplinas gerais de programação. Em um estudo realizado no curso de Engenharia de Software na Universidade de Brasília, \citeonline{pereiraetal} ressaltam que:

\begin{quote}
    ``Entre as influencias encontradas, quanto ao desempenho individual, com base nos resultados da analise de desempenho geral do aluno, observou que 69,9\% dos alunos tiveram um desempenho maior do que o desempenho anterior a esse contato. Ainda sobre a analise desempenho individual destes alunos em disciplinas de programação antes e depois da utilização desta estratégia de ensino, observou-se que 50,3\% dos alunos apresentaram um aumento no desempenho em disciplinas de programação'' \cite[p.218]{pereiraetal}
\end{quote} 

\section{Arquitetura em micro-serviços}
\label{sec:microServicos}

A arquitetura de micro-serviços consiste em variados \textit{softwares} que trabalham independentemente. Em contraposição, existe a abordagem monolítica onde o serviço concentra todas as responsabilidades do software. De fato, a abordagem monolítica é bastante eficaz para um sistema pequeno, pois facilita o \textit{deploy} e desenvolvimento da aplicação; no entanto, enquanto cresce a concentração de funcionalidades em um só sistema, agrava a complexidade do código, dificultando seu entendimento e manutenção, conforme afirmam \citeonline{dmitry2014micro} em On Micro-services Architecture.

A separação de aplicações em módulos visa a flexibilidade de escalar os micros serviços independentemente: ``[\dots] Com a arquitetura monolítica, não é possível escalar cada componente de maneira independente'' \cite[p.24, tradução nossa]{dmitry2014micro}\footnote{\textit{``[\dots] With a monolithic architecture, we can not scale each component independently''}}. Outro benefício na separação das responsabilidades em dois sistemas independentes é o desenvolvimento de novas \textit{features}, manutenção e possível troca de \textit{framework} ou de tecnologia presente no software para algo mais adequado, ou algo mais novo. 

Em uma arquitetura monolítica, mudar o código pode se tornar muito difícil dependendo do tamanho e complexidade da aplicação, de modo coaduno, \citeonline{dmitry2014micro} afirmam: ``[\dots] Com a arquitetura monolítica, é muito difícil (se lê impossível) realizar mudanças.''\cite[p.24, tradução nossa]{dmitry2014micro}\footnote{\textit{``[\dots] With the monolithic architecture, it is very difficult (read impossible) to change it.''}}.

\section{Web APIs}
\label{sec:apis}

\textit{Application Programing Interface} (API) é o termo usado para a representação da interface de uma aplicação. Essa interface dispõe as funções para interação com o sistema. Uma \textit{Web} API é a interface de um serviço \textit{web}, responsável por receber e atender as requisições enviadas ao sistema \cite{masse2011rest, richardson2013restful}.

A comunicação com uma Web API é feita por \textit{requests} utilizando o protocolo HTTP de comunicação. Essa comunicação pode ou não ter envio de informações atreladas. Quando há o envio de informações, um formato utilizado para o envio de dados é o JSON, padrão utilizado para a representação de estruturas de dados \cite{richardson2013restful}.

Aplicações modernas e sistemas baseados em micro-serviços necessitam de comunicação com serviços externos. A utilização de Web APIs é uma alternativa para estabelecer uma ponte de comunicação entre serviços. A API oferece uma lista de funções, que funcionam como uma camada de abstração ao sistema interno. Com isso, os sistemas compartilham informações sem comprometer suas independências \cite{ghebremicael2017transformation}.

\section {Desenvolvimento WEB}
\label{sec:desenvolvimentoWEB}

A definição de Aplicação Web de \citeonline{hadley2006web} é:
``[\dots] um aplicativo Web é definido como um aplicativo dinâmico baseado em comunicação HTTP cujas interações são passíveis de processamento por máquina'' \footnote{\textit{[\dots] a Web application is defined as a dynamic HTTP-based application whose
interactions are amenable to machine processing. [\dots]}} \cite[p.1, tradução nossa]{hadley2006web}. Um exemplo de aplicação web é o site, conjunto de páginas web que compõem uma aplicação.

Para o desenvolvimento de sites existem várias abordagens. Dentre elas, uma abordagem popular é a utilização do \textit{frameweork} \textit{React} — uma biblioteca \textit{javascript} \textit{open-source} desenvolvida pelo \textit{Facebook}. O conceito principal do \textit{React} é a reutilização de componentes de interfaces para a aceleração do processo de desenvolvimento \cite{rawat2020react}.

Para reutilização de componentes \textit{React} são utilizados \textit{Node Packages} — bibliotecas \textit{javascritpt}. Para gerir essas bibliotecas é utilizado o NPM (\textit{Node Package Manager}), um recurso utilizado pelo React para controle de pacotes. Esse recurso permite a utilização de bibliotecas já desenvolvidas na aplicação, visando a otimização do trabalho, de acordo com \citeonline{rawat2020react} ``[\dots] A utilização de pacotes npm em seu empreendimento pode diminuir o tempo esperado para a realização de uma tarefa.''\footnote{\textit{``[\dots] Utilizing npm packages in your venture can diminish the measure of time expected to accomplish the errand.''}}\cite[p.699, tradução nossa]{rawat2020react}.



